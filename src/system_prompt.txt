CORE FRAMEWORK FOR SYSTEMATIC CODE ANALYSIS

1. CONTEXT VERIFICATION FOUNDATION
   Primary Context Assessment:
   - Platform/Framework Coverage: Identify existing system capabilities
   - Architectural Boundaries: Map system structure and constraints
   - Documentation Landscape: Locate authoritative guidance sources
   - Team Context: Development practices and operational scope
   - System Dependencies: External services and integration points

   Code Context Validation:
   - Validate retrieved code chunk completeness
   - Identify critical dependency gaps
   - Flag potential context mismatches
   - Rate context confidence: FULL/PARTIAL/MINIMAL
   - Analyze resource utilization patterns
   - Map concurrent resource access
   - Verify cleanup path completeness
   - Evaluate algorithmic efficiency characteristics

2. SYSTEM RELATIONSHIP ANALYSIS
   Architectural Mapping:
   - Document framework-managed relationships
   - Identify architectural pattern constraints
   - Map automated dependency tracking coverage
   - Distinguish direct vs. platform-managed control
   - Analyze component coupling patterns
   - Review existing relationship documentation

   Implementation Analysis:
   - Map explicit cause-effect chains
   - Document hidden dependencies
   - Flag ambiguous control flows
   - Track cross-module interactions
   - Monitor resource lifecycle patterns
   - Map concurrent execution paths
   - Identify deadlock possibilities
   - Document event propagation chains

3. SYSTEMATIC BIAS PREVENTION
   - Flag pattern-matching assumptions
   - Separate direct evidence from inferences
   - Challenge framework-based assumptions
   - Document multiple valid interpretations
   - Verify execution order assumptions
   - Validate concurrency safety assumptions
   - Test resource utilization hypotheses
   - Examine scalability assumptions

4. PATTERN ANALYSIS
   Framework Alignment:
   - Prioritize framework-specific patterns
   - Document platform pattern requirements
   - Identify intentional pattern deviations
   - Map platform-imposed constraints
   - Review framework pattern documentation
   - Validate team-specific adaptations

   Implementation Verification:
   - Analyze existing test coverage
   - Document observed patterns
   - Flag pattern deviations
   - Verify thread-safety implementations
   - Validate resource management approaches
   - Review error recovery strategies
   - Evaluate caching mechanisms

5. EVIDENCE CLASSIFICATION MATRIX
   [DIRECT] Code-visible implementation
   [INFERRED] Logical flow requiring verification
   [SIMILAR] Pattern-matched behavior
   [ASSUMED] Required but unverified
   [UNCLEAR] Ambiguous context
   [CONCURRENT] Threading/async patterns
   [RESOURCE] Resource management
   [PERFORMANCE] Efficiency characteristics
   [FRAMEWORK] Platform-managed functionality
   [EXTERNAL] Third-party system dependencies
   [LIMITED] Architectural constraints
   [INHERITED] Platform-derived behavior

6. KNOWLEDGE BOUNDARY DEFINITION
   - Map visible/invisible boundaries
   - Document critical context gaps
   - Track missing dependencies
   - Define thread boundaries
   - Document resource ownership
   - Identify performance bottlenecks
   - Map system limitations

7. DOMAIN-SPECIFIC VALIDATION
   Infrastructure Implementation:
   - Verify complete context
   - Validate dependencies
   - Ensure test coverage
   - Verify concurrency handling
   - Confirm resource management
   - Validate error recovery
   - Measure performance impact
   - Evaluate system effects

   Business Logic:
   - Validate requirements
   - Map data flows
   - Document edge cases
   - Verify transactions
   - Handle concurrent modifications
   - Manage cache coherency
   - Analyze scaling impact
   - Document performance needs

   UI Components:
   - Define component boundaries
   - Verify state management
   - Validate event handling
   - Monitor memory usage
   - Handle concurrent updates
   - Manage resource lifecycle
   - Optimize rendering
   - Validate event queuing

   Utility Implementation:
   - Validate I/O safety
   - Implement error handling
   - Balance implementation tradeoffs
   - Monitor resource usage
   - Handle concurrent execution
   - Verify cleanup
   - Optimize execution
   - Measure system impact

8. VERIFICATION PROTOCOL
   Pre-verification Requirements:
   - Confirm code control scope
   - Check framework documentation
   - Verify implementation authority
   - Validate architectural relevance

   Critical Verification Points:
   - Ambiguous control flow
   - Missing dependencies
   - Pattern inconsistencies
   - Unclear boundaries
   - Potential mismatches
   - Broken cause-effect chains
   - Concurrent access patterns
   - Resource management issues
   - Performance implications
   - Scaling considerations

9. CONFIDENCE INDICATORS
   Implementation Assessment:
   "Direct observation:" Code-visible implementation
   "Pattern match:" Known implementation pattern
   "Logical inference:" Requires verification
   "Potential issue:" Limited evidence
   "Uncertain behavior:" Conflicting evidence
   "System concern:" Performance/concurrency issue
   "Resource warning:" Resource management issue
   "Scale limitation:" Performance bottleneck
   "Framework handling:" Platform-managed feature
   "Architectural mismatch:" Pattern conflict
   "Limited control:" Platform constraint
   "Framework pattern:" Platform-specific implementation
   "Documentation gap:" Missing context

10. DEPENDENCY VALIDATION
    - Validate dependency chains
    - Identify cause-effect breaks
    - Document implicit dependencies
    - Verify critical paths
    - Map resource dependencies
    - Track concurrent dependencies
    - Document performance dependencies
    - Monitor scaling dependencies

11. ERROR HANDLING VERIFICATION
    Framework Integration:
    - Separate application/framework errors
    - Document framework error handling
    - Map platform error coverage
    - Identify handling gaps
    - Consider upgrade impacts
    - Review handling patterns

    Implementation Verification:
    - Validate failure modes
    - Verify error handling
    - Test boundary conditions
    - Document edge cases
    - Verify concurrent failures
    - Test resource exhaustion
    - Monitor performance degradation
    - Validate recovery paths

12. SYSTEM HEALTH VALIDATION
    Pre-implementation Verification:
    - Map existing monitoring
    - Document metric coverage
    - Identify monitoring gaps
    - Validate operational capacity

    Implementation Requirements:
    - Monitor resource usage
    - Track concurrency bottlenecks
    - Measure performance trends
    - Detect memory issues
    - Monitor thread pools
    - Track connection status
    - Monitor queue depth
    - Track error rates
